(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{169:function(t,e,r){"use strict";r.r(e);var n=r(0),i=Object(n.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),r("p",[t._v("This documentation can be viewed with "),r("a",{attrs:{href:"https://vuepress.vuejs.org",target:"_blank",rel:"noopener noreferrer"}},[t._v("VuePress"),r("OutboundLink")],1),t._v(" or under the "),r("a",{attrs:{href:"https://mattbaumann.github.io/segmentRouting/",target:"_blank",rel:"noopener noreferrer"}},[t._v("public website"),r("OutboundLink")],1),t._v(".")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),r("p",[t._v("Underneath the MPLS overlay network needs to be a traditional network infrastructure. There needs to be a routing protocol and a transport protocol. This allows router that are not participating in MPLS to receive route updates. Obviously, route updates need to be transported via BGP and the traditional routing protocol.")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),r("p",[t._v("Our application is able to message with the controller over a RESTful HTTP protocol. The controller solves the real-time constraints of BGP and allows our application to focus on rule definition and analysis.")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"challenge-project-segment-routing"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#challenge-project-segment-routing","aria-hidden":"true"}},[this._v("#")]),this._v(" Challenge Project Segment Routing")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"mpls"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mpls","aria-hidden":"true"}},[this._v("#")]),this._v(" MPLS")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("The "),e("em",[this._v("Multi-Protocol Package Label Switching")]),this._v(" protocol allows router to leverage the efficiency of switching with the feature-set of routing. MPLS is the "),e("em",[this._v("data plane")]),this._v(" and uses BGP for the "),e("em",[this._v("control plane")]),this._v("(label and route distribution).")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"segment-routing"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#segment-routing","aria-hidden":"true"}},[this._v("#")]),this._v(" Segment Routing")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"assets/SegmentRouting.png",alt:"Segment Routing Example"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("em",[this._v("Segment Routing")]),this._v(" enhances MPLS with a route controller. The controller may define MPLS routes for individual endpoints, applications, failures or priorities. Those rules are stored in the controller as "),e("em",[this._v("sr policy")]),this._v(". The controller sends BGP updates, to control the packet flows according to the policy, in real time.")])}],!1,null,null,null);e.default=i.exports}}]);